# vue3 的优化总览

## 对比 vue2

对比 vue2，vue3 引入了虚拟 DOM 的观念

vue2 存在的缺陷：

- 源码自身的维护性：数据量大后带来的渲染和更新的性能问题
- 兼容性：想舍弃但是为了兼容一直保留的鸡肋API

vue 3 想带来更好的编程体验

- 更好的 ts 支持
- 更好的的复用实践

## 具体的 vue3 的优化

### 源码优化

目的是为了让代码更易于开发和维护，源码的优化体现在使用 monorepo 和 typescript 管理和开发源码

1. 使用了 monorepo 的管理方式

    vue2 的目录结构
    
    ```text
    src/
        compiler/    -- 模板编译的相关代码
        core/        -- 与平台无关的运行时代码
        platforms/   -- 平台专有代码
        server/      -- 服务端渲染的相关代码
        sfc/         -- .vue 单文件解析相关代码
        shared/      -- 共享工具代码
    ```

    vue3 的目录结构
    ```text
    package/
        compiler-core/
        compiler-dom/
        compiler-sfc/
        compiler-ssr/
        reactivity/
        runtime-core/
        runtime-dom/
        runtime-test/
        server-renderer/
        shared/
        size-check/
        template-explorer/
        vue/
    ```

   - 相对于 Vue2 的源码组织方式，monorepo 把这些模块拆分到不同的 package 中，每个 package 有各自的 API、类型定义和测试，这使得模块的拆分更加细化，职责划分的更明确，模块之间的依赖关系也更加明确
   - package（比如 reactivity 响应库）是可以独立于 vue.js 使用的，这样用户如果只想使用 vue3 的响应能力，可以单独依赖这个响应式库而不用去依赖整个 vue，减小了引用包的体积大小，而 vue2 是做不到这一点的。
   - vue3 自身采用 ts 进行开发，vue2 采用 flow
   - flow 是 facebook 出品的 js 静态类型检查工具，可以以非常小的成本对已有的 js 代码迁入，非常灵活。但是 flow 对于复杂场景类型的检查，支持的并不好。

### 性能优化

vue3 在源代码体积减少方面的优化

- 移除了一些冷门的 feature
- 引入 tree shaking 的技术

tree shaking 技术：
   - tree shaking 依赖 ES2015 模块语法的静态结构（即 import 和 export），通过编译阶段的静态分析，找到没有引入的模块并打上标记
   - 如果你在项目中没有引入 Transition、Keepalived 等组件，那么它们对应的代码就不会被打包，这样间接的减少了项目引入的 vue.js 包的大小

例子：一个 math 模块定义了两个方法`square()`和`cube()`

```ts
export function square(x) {
    return x*x;
}

export function cube(x) {
    return x*x*x;
}
```

同时，在外部只使用`cube()`方法

```ts
import {cube} from './math.ts'
```

math 模块被 webpack 打包生成如下的代码

```js
/* 1 */
/***/(function(module, __webpack_exports__, __webpacke_require__){
    'use strict';
    /* unused harmony export square */
    /* harmony export (immutable) */
    __webpack_exports__['a']=cube;
    function square(x) {
        return x*x;
    }
    
    function cube(x) {
        return x*x*x;
    }
})
```

### 数据劫持优化

vue 区别于 react 的一大特点是数据是`响应式`的，由 DOM 提供这一功能，但是代价是必须劫持数据的访问和更新。当数据发生改变后，为了自动更新 DOM，必须劫持数据的更新，也就是说当数据发生改变后能自动触发一些代码去更新 DOM

> 内容补充：什么是 DOM
> DOM：文档对象模型，是一个网络文档的编程接口。

- 疑难点1：vue 是怎么知道更新哪一片 DOM 的
  - 因为在渲染 DOM 的时候访问了数据，我们可以对它进行访问劫持，这样就在内部建立了依赖关系，也就知道了数据对应的 DOM 是什么
